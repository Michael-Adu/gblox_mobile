<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Bluetooth</title><style>
/* cspell:disable-file */
/* webkit printing magic: print all background colors */
html {
	-webkit-print-color-adjust: exact;
}
* {
	box-sizing: border-box;
	-webkit-print-color-adjust: exact;
}

html,
body {
	margin: 0;
	padding: 0;
}
@media only screen {
	body {
		margin: 2em auto;
		max-width: 900px;
		color: rgb(55, 53, 47);
	}
}

body {
	line-height: 1.5;
	white-space: pre-wrap;
}

a,
a.visited {
	color: inherit;
	text-decoration: underline;
}

.pdf-relative-link-path {
	font-size: 80%;
	color: #444;
}

h1,
h2,
h3 {
	letter-spacing: -0.01em;
	line-height: 1.2;
	font-weight: 600;
	margin-bottom: 0;
}

.page-title {
	font-size: 2.5rem;
	font-weight: 700;
	margin-top: 0;
	margin-bottom: 0.75em;
}

h1 {
	font-size: 1.875rem;
	margin-top: 1.875rem;
}

h2 {
	font-size: 1.5rem;
	margin-top: 1.5rem;
}

h3 {
	font-size: 1.25rem;
	margin-top: 1.25rem;
}

.source {
	border: 1px solid #ddd;
	border-radius: 3px;
	padding: 1.5em;
	word-break: break-all;
}

.callout {
	border-radius: 3px;
	padding: 1rem;
}

figure {
	margin: 1.25em 0;
	page-break-inside: avoid;
}

figcaption {
	opacity: 0.5;
	font-size: 85%;
	margin-top: 0.5em;
}

mark {
	background-color: transparent;
}

.indented {
	padding-left: 1.5em;
}

hr {
	background: transparent;
	display: block;
	width: 100%;
	height: 1px;
	visibility: visible;
	border: none;
	border-bottom: 1px solid rgba(55, 53, 47, 0.09);
}

img {
	max-width: 100%;
}

@media only print {
	img {
		max-height: 100vh;
		object-fit: contain;
	}
}

@page {
	margin: 1in;
}

.collection-content {
	font-size: 0.875rem;
}

.column-list {
	display: flex;
	justify-content: space-between;
}

.column {
	padding: 0 1em;
}

.column:first-child {
	padding-left: 0;
}

.column:last-child {
	padding-right: 0;
}

.table_of_contents-item {
	display: block;
	font-size: 0.875rem;
	line-height: 1.3;
	padding: 0.125rem;
}

.table_of_contents-indent-1 {
	margin-left: 1.5rem;
}

.table_of_contents-indent-2 {
	margin-left: 3rem;
}

.table_of_contents-indent-3 {
	margin-left: 4.5rem;
}

.table_of_contents-link {
	text-decoration: none;
	opacity: 0.7;
	border-bottom: 1px solid rgba(55, 53, 47, 0.18);
}

table,
th,
td {
	border: 1px solid rgba(55, 53, 47, 0.09);
	border-collapse: collapse;
}

table {
	border-left: none;
	border-right: none;
}

th,
td {
	font-weight: normal;
	padding: 0.25em 0.5em;
	line-height: 1.5;
	min-height: 1.5em;
	text-align: left;
}

th {
	color: rgba(55, 53, 47, 0.6);
}

ol,
ul {
	margin: 0;
	margin-block-start: 0.6em;
	margin-block-end: 0.6em;
}

li > ol:first-child,
li > ul:first-child {
	margin-block-start: 0.6em;
}

ul > li {
	list-style: disc;
}

ul.to-do-list {
	text-indent: -1.7em;
}

ul.to-do-list > li {
	list-style: none;
}

.to-do-children-checked {
	text-decoration: line-through;
	opacity: 0.375;
}

ul.toggle > li {
	list-style: none;
}

ul {
	padding-inline-start: 1.7em;
}

ul > li {
	padding-left: 0.1em;
}

ol {
	padding-inline-start: 1.6em;
}

ol > li {
	padding-left: 0.2em;
}

.mono ol {
	padding-inline-start: 2em;
}

.mono ol > li {
	text-indent: -0.4em;
}

.toggle {
	padding-inline-start: 0em;
	list-style-type: none;
}

/* Indent toggle children */
.toggle > li > details {
	padding-left: 1.7em;
}

.toggle > li > details > summary {
	margin-left: -1.1em;
}

.selected-value {
	display: inline-block;
	padding: 0 0.5em;
	background: rgba(206, 205, 202, 0.5);
	border-radius: 3px;
	margin-right: 0.5em;
	margin-top: 0.3em;
	margin-bottom: 0.3em;
	white-space: nowrap;
}

.collection-title {
	display: inline-block;
	margin-right: 1em;
}

.simple-table {
	margin-top: 1em;
	font-size: 0.875rem;
}

.simple-table-header {
	background: rgb(247, 246, 243);
	color: black;
	font-weight: 500;
}

time {
	opacity: 0.5;
}

.icon {
	display: inline-block;
	max-width: 1.2em;
	max-height: 1.2em;
	text-decoration: none;
	vertical-align: text-bottom;
	margin-right: 0.5em;
}

img.icon {
	border-radius: 3px;
}

.user-icon {
	width: 1.5em;
	height: 1.5em;
	border-radius: 100%;
	margin-right: 0.5rem;
}

.user-icon-inner {
	font-size: 0.8em;
}

.text-icon {
	border: 1px solid #000;
	text-align: center;
}

.page-cover-image {
	display: block;
	object-fit: cover;
	width: 100%;
	max-height: 30vh;
}

.page-header-icon {
	font-size: 3rem;
	margin-bottom: 1rem;
}

.page-header-icon-with-cover {
	margin-top: -0.72em;
	margin-left: 0.07em;
}

.page-header-icon img {
	border-radius: 3px;
}

.link-to-page {
	margin: 1em 0;
	padding: 0;
	border: none;
	font-weight: 500;
}

p > .user {
	opacity: 0.5;
}

td > .user,
td > time {
	white-space: nowrap;
}

input[type="checkbox"] {
	transform: scale(1.5);
	margin-right: 0.6em;
	vertical-align: middle;
}

p {
	margin-top: 0.5em;
	margin-bottom: 0.5em;
}

.image {
	border: none;
	margin: 1.5em 0;
	padding: 0;
	border-radius: 0;
	text-align: center;
}

.code,
code {
	background: rgba(135, 131, 120, 0.15);
	border-radius: 3px;
	padding: 0.2em 0.4em;
	border-radius: 3px;
	font-size: 85%;
	tab-size: 2;
}

code {
	color: #eb5757;
}

.code {
	padding: 1.5em 1em;
}

.code-wrap {
	white-space: pre-wrap;
	word-break: break-all;
}

.code > code {
	background: none;
	padding: 0;
	font-size: 100%;
	color: inherit;
}

blockquote {
	font-size: 1.25em;
	margin: 1em 0;
	padding-left: 1em;
	border-left: 3px solid rgb(55, 53, 47);
}

.bookmark {
	text-decoration: none;
	max-height: 8em;
	padding: 0;
	display: flex;
	width: 100%;
	align-items: stretch;
}

.bookmark-title {
	font-size: 0.85em;
	overflow: hidden;
	text-overflow: ellipsis;
	height: 1.75em;
	white-space: nowrap;
}

.bookmark-text {
	display: flex;
	flex-direction: column;
}

.bookmark-info {
	flex: 4 1 180px;
	padding: 12px 14px 14px;
	display: flex;
	flex-direction: column;
	justify-content: space-between;
}

.bookmark-image {
	width: 33%;
	flex: 1 1 180px;
	display: block;
	position: relative;
	object-fit: cover;
	border-radius: 1px;
}

.bookmark-description {
	color: rgba(55, 53, 47, 0.6);
	font-size: 0.75em;
	overflow: hidden;
	max-height: 4.5em;
	word-break: break-word;
}

.bookmark-href {
	font-size: 0.75em;
	margin-top: 0.25em;
}

.sans { font-family: ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol"; }
.code { font-family: "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace; }
.serif { font-family: Lyon-Text, Georgia, ui-serif, serif; }
.mono { font-family: iawriter-mono, Nitti, Menlo, Courier, monospace; }
.pdf .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK JP'; }
.pdf:lang(zh-CN) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK SC'; }
.pdf:lang(zh-TW) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK TC'; }
.pdf:lang(ko-KR) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK KR'; }
.pdf .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.pdf .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK JP'; }
.pdf:lang(zh-CN) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK SC'; }
.pdf:lang(zh-TW) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK TC'; }
.pdf:lang(ko-KR) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK KR'; }
.pdf .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.highlight-default {
	color: rgba(55, 53, 47, 1);
}
.highlight-gray {
	color: rgba(120, 119, 116, 1);
	fill: rgba(145, 145, 142, 1);
}
.highlight-brown {
	color: rgba(159, 107, 83, 1);
	fill: rgba(187, 132, 108, 1);
}
.highlight-orange {
	color: rgba(217, 115, 13, 1);
	fill: rgba(215, 129, 58, 1);
}
.highlight-yellow {
	color: rgba(203, 145, 47, 1);
	fill: rgba(203, 148, 51, 1);
}
.highlight-teal {
	color: rgba(68, 131, 97, 1);
	fill: rgba(108, 155, 125, 1);
}
.highlight-blue {
	color: rgba(51, 126, 169, 1);
	fill: rgba(91, 151, 189, 1);
}
.highlight-purple {
	color: rgba(144, 101, 176, 1);
	fill: rgba(167, 130, 195, 1);
}
.highlight-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(205, 116, 159, 1);
}
.highlight-red {
	color: rgba(212, 76, 71, 1);
	fill: rgba(225, 111, 100, 1);
}
.highlight-gray_background {
	background: rgba(241, 241, 239, 1);
}
.highlight-brown_background {
	background: rgba(244, 238, 238, 1);
}
.highlight-orange_background {
	background: rgba(251, 236, 221, 1);
}
.highlight-yellow_background {
	background: rgba(251, 243, 219, 1);
}
.highlight-teal_background {
	background: rgba(237, 243, 236, 1);
}
.highlight-blue_background {
	background: rgba(231, 243, 248, 1);
}
.highlight-purple_background {
	background: rgba(244, 240, 247, 0.8);
}
.highlight-pink_background {
	background: rgba(249, 238, 243, 0.8);
}
.highlight-red_background {
	background: rgba(253, 235, 236, 1);
}
.block-color-default {
	color: inherit;
	fill: inherit;
}
.block-color-gray {
	color: rgba(120, 119, 116, 1);
	fill: rgba(145, 145, 142, 1);
}
.block-color-brown {
	color: rgba(159, 107, 83, 1);
	fill: rgba(187, 132, 108, 1);
}
.block-color-orange {
	color: rgba(217, 115, 13, 1);
	fill: rgba(215, 129, 58, 1);
}
.block-color-yellow {
	color: rgba(203, 145, 47, 1);
	fill: rgba(203, 148, 51, 1);
}
.block-color-teal {
	color: rgba(68, 131, 97, 1);
	fill: rgba(108, 155, 125, 1);
}
.block-color-blue {
	color: rgba(51, 126, 169, 1);
	fill: rgba(91, 151, 189, 1);
}
.block-color-purple {
	color: rgba(144, 101, 176, 1);
	fill: rgba(167, 130, 195, 1);
}
.block-color-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(205, 116, 159, 1);
}
.block-color-red {
	color: rgba(212, 76, 71, 1);
	fill: rgba(225, 111, 100, 1);
}
.block-color-gray_background {
	background: rgba(241, 241, 239, 1);
}
.block-color-brown_background {
	background: rgba(244, 238, 238, 1);
}
.block-color-orange_background {
	background: rgba(251, 236, 221, 1);
}
.block-color-yellow_background {
	background: rgba(251, 243, 219, 1);
}
.block-color-teal_background {
	background: rgba(237, 243, 236, 1);
}
.block-color-blue_background {
	background: rgba(231, 243, 248, 1);
}
.block-color-purple_background {
	background: rgba(244, 240, 247, 0.8);
}
.block-color-pink_background {
	background: rgba(249, 238, 243, 0.8);
}
.block-color-red_background {
	background: rgba(253, 235, 236, 1);
}
.select-value-color-pink { background-color: rgba(245, 224, 233, 1); }
.select-value-color-purple { background-color: rgba(232, 222, 238, 1); }
.select-value-color-green { background-color: rgba(219, 237, 219, 1); }
.select-value-color-gray { background-color: rgba(227, 226, 224, 1); }
.select-value-color-opaquegray { background-color: rgba(255, 255, 255, 0.0375); }
.select-value-color-orange { background-color: rgba(250, 222, 201, 1); }
.select-value-color-brown { background-color: rgba(238, 224, 218, 1); }
.select-value-color-red { background-color: rgba(255, 226, 221, 1); }
.select-value-color-yellow { background-color: rgba(253, 236, 200, 1); }
.select-value-color-blue { background-color: rgba(211, 229, 239, 1); }

.checkbox {
	display: inline-flex;
	vertical-align: text-bottom;
	width: 16;
	height: 16;
	background-size: 16px;
	margin-left: 2px;
	margin-right: 5px;
}

.checkbox-on {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20width%3D%2216%22%20height%3D%2216%22%20fill%3D%22%2358A9D7%22%2F%3E%0A%3Cpath%20d%3D%22M6.71429%2012.2852L14%204.9995L12.7143%203.71436L6.71429%209.71378L3.28571%206.2831L2%207.57092L6.71429%2012.2852Z%22%20fill%3D%22white%22%2F%3E%0A%3C%2Fsvg%3E");
}

.checkbox-off {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20x%3D%220.75%22%20y%3D%220.75%22%20width%3D%2214.5%22%20height%3D%2214.5%22%20fill%3D%22white%22%20stroke%3D%22%2336352F%22%20stroke-width%3D%221.5%22%2F%3E%0A%3C%2Fsvg%3E");
}
	
</style></head><body><article id="8bc8d462-3c54-494c-a438-a6e1766c4b11" class="page sans"><header><h1 class="page-title">Bluetooth</h1><table class="properties"><tbody><tr class="property-row property-row-select"><th><span class="icon property-icon"><svg viewBox="0 0 14 14" style="width:14px;height:14px;display:block;fill:rgba(55, 53, 47, 0.4);flex-shrink:0;-webkit-backface-visibility:hidden" class="typesSelect"><path d="M7,13 C10.31348,13 13,10.31371 13,7 C13,3.68629 10.31348,1 7,1 C3.68652,1 1,3.68629 1,7 C1,10.31371 3.68652,13 7,13 Z M3.75098,5.32278 C3.64893,5.19142 3.74268,5 3.90869,5 L10.09131,5 C10.25732,5 10.35107,5.19142 10.24902,5.32278 L7.15771,9.29703 C7.07764,9.39998 6.92236,9.39998 6.84229,9.29703 L3.75098,5.32278 Z"></path></svg></span>Fully Documented</th><td><span class="selected-value select-value-color-green">Fully Documented</span></td></tr></tbody></table></header><div class="page-body"><nav id="50b31f3c-ffc5-470e-b6ba-a00365640626" class="block-color-gray table_of_contents"><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#472f956b-c734-48b7-b579-152f5606ab97">Packages used:</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#c5575919-c498-4567-b7fb-412f02557c89">Modular Widgets used:</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#d23c8409-247c-4294-90fa-b8f4c821a754">Pages Used:</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#954dd521-0102-4658-8328-c93cf557badf">Flutter Bluetooth Serial</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#34f8fd57-a380-44bc-810e-9e116bdc85f4"><code>class _DeviceWithAvailability</code></a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#369ba15f-d5e2-41c0-b3a3-30baa942a81f"><code>class _DiscoveryPage</code></a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#919edcf3-9630-4691-807f-ef619da210a5">Getting Bonded Devices</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#8d60807d-ad45-4f5f-9529-0a0e636b641a">Scanning for New Devices</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#d512f1d2-03fd-4a0d-b71c-c7b845d1221e">Building the <code>BluetoothCards</code></a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#6b5f70f3-2ec4-4e80-b8b3-74649a59d1b8">Searching Device via Address</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#aa95034d-83c3-4842-8572-f0a713bd095e">Restarting the Device Scanning</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#d3a0a0d9-cb86-4c92-823a-b4c0d0a295b5">What is Left?</a></div></nav><ul id="3a68eaee-0d19-4a0f-9491-b4b60bc64353" class="bulleted-list"><li style="list-style-type:disc">Stateful Widget to display the Bluetooth integration.</li></ul><ul id="1d105f4b-0042-4330-b200-897596505924" class="bulleted-list"><li style="list-style-type:disc">Comprises of Flutter Bluetooth Serial and custom classes for organization.</li></ul><div id="e92f94bb-4795-45f8-8f45-d63eea77e2de" class="column-list"><div id="a10e5f34-5b65-4dcc-99dc-a9ad298d975e" style="width:50%" class="column"><h1 id="472f956b-c734-48b7-b579-152f5606ab97" class="">Packages used:</h1><ol type="1" id="eb67075e-eb06-4252-9a9d-60f7da66c667" class="numbered-list" start="1"><li>Flutter Bluetooth Serial<figure id="367de9b5-3b05-4371-aa7e-f48272154de3"><a href="https://pub.dev/packages/flutter_bluetooth_serial" class="bookmark source"><div class="bookmark-info"><div class="bookmark-text"><div class="bookmark-title">flutter_bluetooth_serial | Flutter Package</div><div class="bookmark-description">Flutter basic implementation for Classical Bluetooth (only RFCOMM for now). The first goal of this project, started by @edufolly was making an interface for Serial Port Protocol (HC-05 Adapter). Now the plugin features: Adapter status monitoring, Turning adapter on and off, Opening settings, Discovering devices (and requesting discoverability), Listing bonded devices and pairing new ones, Connecting to multiple devices at the same time, Sending and receiving data (multiple connections).</div></div><div class="bookmark-href"><img src="https://pub.dev/static/img/flutter-logo-32x32.png?hash=4hh64sfc160bkthaobnlp5brguc4hfne" class="icon bookmark-icon"/>https://pub.dev/packages/flutter_bluetooth_serial</div></div><img src="https://pub.dev/static/img/pub-dev-icon-cover-image.png?hash=vg86r2r3mbs62hiv4ldop0ife5um2g5g" class="bookmark-image"/></a></figure></li></ol><ol type="1" id="0d90f5fb-9f43-4da5-99e8-e84012734bdd" class="numbered-list" start="2"><li>Scroll Snap List<figure id="8c6a600f-91e9-4347-a40d-8c199fa9e48b"><a href="https://pub.dev/packages/scroll_snap_list" class="bookmark source"><div class="bookmark-info"><div class="bookmark-text"><div class="bookmark-title">scroll_snap_list | Flutter Package</div><div class="bookmark-description">A wrapper for ListView.builder widget that allows &quot;snaping&quot; event to an item at the end of user-scroll. This widget allows unrestricted scrolling (unlike other widget that only able to &quot;snap&quot; to left/right neighbor at a time).</div></div><div class="bookmark-href"><img src="https://pub.dev/static/img/flutter-logo-32x32.png?hash=4hh64sfc160bkthaobnlp5brguc4hfne" class="icon bookmark-icon"/>https://pub.dev/packages/scroll_snap_list</div></div><img src="https://pub.dev/static/img/pub-dev-icon-cover-image.png?hash=vg86r2r3mbs62hiv4ldop0ife5um2g5g" class="bookmark-image"/></a></figure></li></ol></div><div id="1146a851-be29-4eeb-be45-4b46109543fe" style="width:50%" class="column"><h1 id="c5575919-c498-4567-b7fb-412f02557c89" class="">Modular Widgets used:</h1><ol type="1" id="ce8c4804-ef90-4ba6-a5f0-f065698eaa5e" class="numbered-list" start="1"><li>BluetoothCard<em> - </em><code><em>gblox_mobile\lib\components\Bluetooth\bluetooth_card.dart</em></code></li></ol><h1 id="d23c8409-247c-4294-90fa-b8f4c821a754" class="">Pages Used:</h1><ol type="1" id="78465c0d-3906-4f07-86bb-4465b8e3a19f" class="numbered-list" start="1"><li>Connection In Progress - <code><em>gblox_mobile\lib\components\Bluetooth\connection_in_progress.dart</em></code></li></ol><p id="b1606a7d-6b65-48d3-9e91-cd22fff72e52" class="">
</p></div></div><p id="f86da13f-5b7f-45e7-b5c7-7c7c7545c3ff" class="">
</p><h1 id="954dd521-0102-4658-8328-c93cf557badf" class="">Flutter Bluetooth Serial</h1><ul id="f570e1c6-b536-4a44-9567-5e7ae3aa3b30" class="bulleted-list"><li style="list-style-type:disc">With this package, the device is able to scan for Bluetooth devices, as well as show previously paired devices. It uses the devices native Bluetooth capabilities, and assigns the connected device to <code>activeConnection</code> in <code>global_variables.dart</code>. </li></ul><ul id="cc1f3655-601b-40b8-9679-6a69442996d0" class="bulleted-list"><li style="list-style-type:disc">The results are filtered to remove any devices that do not contain “MELLO”, “MINGO” or “ARDUINO” in the name. This is to ensure that robots are only selected.</li></ul><h2 id="34f8fd57-a380-44bc-810e-9e116bdc85f4" class=""><code>class _DeviceWithAvailability</code></h2><ul id="0c2b8b8b-4e8c-4113-9732-5ac19e707660" class="bulleted-list"><li style="list-style-type:disc">This class is used to organize the Bluetooth data with regards to the devices. It holds:<ul id="df7e7b55-594a-40e9-9e44-44f4143ba56c" class="bulleted-list"><li style="list-style-type:circle"><code>BluetoothDevice - device</code><ul id="779f889d-8d77-48ec-9729-cafe725f6b13" class="bulleted-list"><li style="list-style-type:square">Class that is provided by the Flutter Bluetooth Serial package. Holds all Bluetooth information about the device, including status on if it is connected or not. This is necessary for sending commands to the robot.</li></ul></li></ul><ul id="df2054df-b3a7-42d0-841a-39500fc52ec5" class="bulleted-list"><li style="list-style-type:circle"><code>_DeviceAvailability - availability</code><ul id="4a5e27fe-c468-48fd-aa1e-ea18e3122792" class="bulleted-list"><li style="list-style-type:square">Enum used to tell if the device is currently available for pairing/connecting.</li></ul></li></ul><ul id="c40d6491-42b5-4bc0-aa7f-029e7ba3ae49" class="bulleted-list"><li style="list-style-type:circle"><code>String - type</code><ul id="f9c1203a-5fda-4daf-adb6-1c324f843c68" class="bulleted-list"><li style="list-style-type:square">String to pass into <code>BluetoothCard</code> to use the appropriate SVG for the Bluetooth device.</li></ul></li></ul><ul id="7b6e60c9-653b-4f88-8cfc-8fd24be1b454" class="bulleted-list"><li style="list-style-type:circle"><code>int - rssi</code><ul id="6e7d0036-afe8-48ef-a9a4-b6585071015d" class="bulleted-list"><li style="list-style-type:square">Integer holding the RSSI value indicating the strength of the <code>bluetooth</code> signal. A device with an RSSI close to 0 (e.g. -25) should automatically connect, since it is most likely the case that the device is placed on top of the robot.</li></ul></li></ul></li></ul><h2 id="369ba15f-d5e2-41c0-b3a3-30baa942a81f" class=""><code>class _DiscoveryPage</code></h2><ul id="60b6cc1c-fbf1-4938-9349-efd50d8e07e5" class="bulleted-list"><li style="list-style-type:disc">This class is responsible for initializing the Stream Subscription for the Bluetooth devices, discovering new devices and retrieving paired devices. </li></ul><h3 id="919edcf3-9630-4691-807f-ef619da210a5" class="">Getting Bonded Devices</h3><div id="cf3de1e1-b055-4c9c-89b0-89bbe9836232" class="column-list"><div id="eba6eb9e-bb97-4e2f-8431-ac5244be26f4" style="width:56.25%" class="column"><pre id="ee2c4d90-3d29-4d0b-bfd0-2f7c77540700" class="code"><code>FlutterBluetoothSerial.instance
        .getBondedDevices()
        .then((List&lt;BluetoothDevice&gt; bondedDevices) async {
      var device;
      for (int i = 0; i &lt; bondedDevices.length; i++) {
        if (bondedDevices[i].isConnected == true) {
          var deviceType;
          device = bondedDevices[i];
          if (device.name!.contains(&quot;HC&quot;)) {
            deviceType = &quot;HC&quot;;
          } else if (device.name!.contains(&quot;MELLO&quot;)) {
            deviceType = &quot;Mello&quot;;
          } else if (device.name!.contains(&quot;MINGO&quot;)) {
            deviceType = &quot;Mingo&quot;;
          }

          try {
            await BluetoothConnection.toAddress(bondedDevices[i].address)
                .catchError((onError) async {
              global.activeConnection.finish();
              setState(() {
                allDevices[i] = _DeviceWithAvailability(
                    BluetoothDevice(
                      name: bondedDevices[i].name ?? &#x27;&#x27;,
                      address: bondedDevices[i].address,
                      type: bondedDevices[i].type,
                      isConnected: false,
                      bondState: BluetoothBondState.bonded,
                    ),
                    _DeviceAvailability.no,
                    deviceType,
                    0);
              });
            });
          } catch (ex) {}
        }
      }
      setState(() {
        for (int i = 0; i &lt; bondedDevices.length; i++) {
          if (bondedDevices[i].name!.contains(&quot;HC&quot;)) {
            allDevices.add(_DeviceWithAvailability(
                bondedDevices[i], _DeviceAvailability.maybe, &quot;Arduino&quot;, 0));
          } else if (bondedDevices[i].name!.contains(&quot;MELLO&quot;)) {
            allDevices.add(_DeviceWithAvailability(
                bondedDevices[i], _DeviceAvailability.maybe, &quot;Mello&quot;, 0));
          } else if (bondedDevices[i].name!.contains(&quot;MINGO&quot;)) {
            allDevices.add(_DeviceWithAvailability(
                bondedDevices[i], _DeviceAvailability.maybe, &quot;Mingo&quot;, 0));
          }
        }
      });
    });</code></pre></div><div id="f2fb73e9-5533-4873-ab03-839052eebb0b" style="width:43.75000000000001%" class="column"><ul id="95b547af-2c6a-4c52-8988-790f72a5669d" class="bulleted-list"><li style="list-style-type:disc">The bonded devices are retrieved using <code>FlutterBluetoothSerial.instance.getBondedDevices()</code>.</li></ul><ul id="b0b5f86b-ec57-4696-ad10-123721d706d4" class="bulleted-list"><li style="list-style-type:disc">The list of bonded devices are then filtered to remove any devices that are not Mingo Blox robots and disconnects any already connected devices. This means that whenever the <code>DiscoveryPage</code> is opened, all devices are disconnected. Note that this does not mean that they are unbonded/unpaired.</li></ul><ul id="f60d289d-71b2-44a2-8f0e-d5bfac4ee0e7" class="bulleted-list"><li style="list-style-type:disc">All devices are added to <code>allDevices</code>, the main list used to display the available devices.</li></ul></div></div><p id="770c4ca4-ec21-4fc7-8579-af7ecd752442" class=""> </p><h3 id="8d60807d-ad45-4f5f-9529-0a0e636b641a" class="">Scanning for New Devices</h3><div id="6a666ac7-5ecb-4947-a017-8f2212f9c1c8" class="column-list"><div id="680f8871-cc70-4ee3-9504-7ec6bf7f4e96" style="width:56.25%" class="column"><pre id="a3dd52f5-7c1b-48ea-8b23-4c05e43df9ef" class="code"><code>void _startDiscovery() {
    _streamSubscription =
        FlutterBluetoothSerial.instance.startDiscovery().listen((r) {
      setState(() {
        final existingIndex = results.indexWhere(
            (element) =&gt; element.device.address == r.device.address);
        if (existingIndex &gt;= 0)
          results[existingIndex] = r;
        else
          results.add(r);
        if (allDevices.any((e) =&gt; e.device == r.device)) {
          var deviceName;
          if (r.device.name!.contains(&quot;HC&quot;)) {
            deviceName = &quot;HC&quot;;
          } else if (r.device.name!.contains(&quot;MELLO&quot;)) {
            deviceName = &quot;Mello&quot;;
          } else if (r.device.name!.contains(&quot;MINGO&quot;)) {
            deviceName = &quot;Mingo&quot;;
          } else {
            deviceName = &quot;Arduino&quot;;
          }
          setState(() {
            allDevices[allDevices
                    .indexWhere((element) =&gt; element.device == r.device)] =
                _DeviceWithAvailability(
                    r.device, _DeviceAvailability.yes, deviceName, r.rssi);
          });
        } else {
          if (r.device.name!.contains(&quot;HC&quot;)) {
            allDevices.add(_DeviceWithAvailability(
                r.device, _DeviceAvailability.yes, &quot;Arudino&quot;, r.rssi));
          } else if (r.device.name!.contains(&quot;MELLO&quot;)) {
            allDevices.add(_DeviceWithAvailability(
                r.device, _DeviceAvailability.yes, &quot;Mello&quot;, r.rssi));
          } else if (r.device.name!.contains(&quot;MINGO&quot;)) {
            allDevices.add(_DeviceWithAvailability(
                r.device, _DeviceAvailability.yes, &quot;Mingo&quot;, r.rssi));
          }
        }
        // }
      });
    });

    _streamSubscription!.onDone(() {
      setState(() {
        isDiscovering = false;
      });
    });
  }</code></pre></div><div id="0c77ee9c-b6f0-4359-bd51-2c09f041cd78" style="width:43.75000000000001%" class="column"><ul id="ffcbd5b7-b13f-44ed-9bc5-8f6decdc1554" class="bulleted-list"><li style="list-style-type:disc">This function assigns the <code>FlutterBluetoothSerial.instance.startDiscovery().listen</code> to the stream subscription.</li></ul><ul id="4ba89b8d-39ed-45b6-9523-4034087d658c" class="bulleted-list"><li style="list-style-type:disc">When a new device is detected, it applies the filter to ensure the device is a robot, and checks if it is already a bonded device.</li></ul><ul id="21939ef0-1373-42ad-a662-a87f17c994fc" class="bulleted-list"><li style="list-style-type:disc">If the robot has already been bonded, the robot will not be added to <code>allDevices</code>, but rather the entry in the list is updated with a new <code>_DeviceAvailability</code> value (<code>_DeviceAvailability.yes</code>) and its appropriate <code>rssi</code>.</li></ul></div></div><p id="c143b822-4924-4a6c-8525-e06948c84a08" class="">
</p><h3 id="d512f1d2-03fd-4a0d-b71c-c7b845d1221e" class="">Building the <code>BluetoothCards</code></h3><div id="34910e57-586c-4f9d-93dc-3027bc2563d5" class="column-list"><div id="43e6b475-737e-4379-83de-659638a81662" style="width:56.25%" class="column"><pre id="a088f3ab-4be6-4da6-bb97-0c13ad900d22" class="code"><code>Widget _buildListItem(BuildContext context, int index) {
    late _DeviceWithAvailability result;

    result = allDevices[index];
    final device = result.device;
    final address = device.address;
    late bool availability;
    switch (result.availability) {
      case _DeviceAvailability.no:
        availability = false;
        break;
      case _DeviceAvailability.yes:
        availability = true;
        break;
      case _DeviceAvailability.maybe:
        availability = false;
        break;
    }
    return Container(
        width: _cardSize * 1.1,
        height: _cardSize,
        child: Container(
            padding: const EdgeInsets.all(15),
            margin: const EdgeInsets.fromLTRB(0, 0, 0, 30),
            child: BluetoothCard(
              device: device,
              enabled: availability,
              type: result.type,
              rssi: result.rssi,
              onTap: () async {
                bool bonded = false;
                try {
                  if (device.isBonded) {
                    global.activeConnection =
                        await BluetoothConnection.toAddress(address)
                            .whenComplete(() =&gt; setState(() {
                                  allDevices[allDevices.indexOf(result)] =
                                      _DeviceWithAvailability(
                                          BluetoothDevice(
                                            name: device.name ?? &#x27;&#x27;,
                                            address: address,
                                            type: device.type,
                                            isConnected: true,
                                            bondState: bonded
                                                ? BluetoothBondState.bonded
                                                : BluetoothBondState.none,
                                          ),
                                          result.availability,
                                          result.type,
                                          result.rssi);
                                  print(bonded
                                      ? BluetoothBondState.bonded
                                      : BluetoothBondState.none);
                                }));
                  } else {
                    bonded = (await FlutterBluetoothSerial.instance
                        .bondDeviceAtAddress(address))!;
                    global.activeConnection =
                        await BluetoothConnection.toAddress(address)
                            .whenComplete(() =&gt; setState(() {
                                  allDevices[allDevices.indexOf(result)] =
                                      _DeviceWithAvailability(
                                          BluetoothDevice(
                                            name: device.name ?? &#x27;&#x27;,
                                            address: address,
                                            type: device.type,
                                            bondState:
                                                BluetoothBondState.bonded,
                                          ),
                                          result.availability,
                                          result.type,
                                          result.rssi);
                                  print(bonded
                                      ? BluetoothBondState.bonded
                                      : BluetoothBondState.none);
                                }));
                  }
                  setState(() {
                    allDevices[allDevices.indexOf(result)] =
                        _DeviceWithAvailability(
                            BluetoothDevice(
                              name: device.name ?? &#x27;&#x27;,
                              address: address,
                              type: device.type,
                              bondState: bonded
                                  ? BluetoothBondState.bonded
                                  : BluetoothBondState.none,
                            ),
                            result.availability,
                            result.type,
                            result.rssi);
                    print(bonded
                        ? BluetoothBondState.bonded
                        : BluetoothBondState.none);
                  });
                } catch (ex) {
                  print(ex);
                }
              },
              onLongPress: () async {
                try {
                  bool bonded = false;
                  if (device.isBonded) {
                    print(&#x27;Unbonding from ${device.address}...&#x27;);
                    await FlutterBluetoothSerial.instance
                        .removeDeviceBondWithAddress(address);
                    print(&#x27;Unbonding from ${device.address} has succed&#x27;);
                  } else {
                    print(&#x27;Bonding with ${device.address}...&#x27;);
                    bonded = (await FlutterBluetoothSerial.instance
                        .bondDeviceAtAddress(address))!;
                    print(
                        &#x27;Bonding with ${device.address} has ${bonded ? &#x27;succed&#x27; : &#x27;failed&#x27;}.&#x27;);
                  }
                  setState(() {
                    allDevices[allDevices.indexOf(result)] =
                        _DeviceWithAvailability(
                            BluetoothDevice(
                              name: device.name ?? &#x27;&#x27;,
                              address: address,
                              type: device.type,
                              bondState: bonded
                                  ? BluetoothBondState.bonded
                                  : BluetoothBondState.none,
                            ),
                            result.availability,
                            result.type,
                            result.rssi);
                  });
                } catch (ex) {
                  showDialog(
                    context: context,
                    builder: (BuildContext context) {
                      return AlertDialog(
                        title: const Text(&#x27;Error occured while bonding&#x27;),
                        content: Text(&quot;${ex.toString()}&quot;),
                        actions: &lt;Widget&gt;[
                          TextButton(
                            child: Text(&quot;Close&quot;),
                            onPressed: () {
                              Navigator.of(context).pop();
                            },
                          ),
                        ],
                      );
                    },
                  );
                }
              },
            )));
  }</code></pre></div><div id="53443dfa-3a2c-45aa-9b38-e3349a827071" style="width:43.75000000000001%" class="column"><ul id="14ca29d9-2fb9-472d-980a-ef7458772a2c" class="bulleted-list"><li style="list-style-type:disc">The cards used with the Scroll Snap List are generated with this Widget builder.</li></ul><ul id="a4295892-ba29-4f6e-aa9f-d41cdc26bbf8" class="bulleted-list"><li style="list-style-type:disc">It uses creates the Widgets using <code>allDevices</code>, and assigns a function to be run upon tapping or long-pressing the card.</li></ul></div></div><p id="fa9481f8-162c-48d2-b1dd-69f720602a27" class="">
</p><h3 id="6b5f70f3-2ec4-4e80-b8b3-74649a59d1b8" class="">Searching Device via Address</h3><ul id="0ba5f57f-5f20-46ed-bb0a-5b98917deae0" class="bulleted-list"><li style="list-style-type:disc">With the possibility of multiple devices in a room, the user should be able to filter out the rest to connect to their own robot. The user can use the strength signal displayed on the <code>BluetoothCard</code> to discern from other devices, however the choice to filter out all results with the device address is also available. The unique Bluetooth device address is to be supplied with with ever Mingo Blox robot, either on the box as a sticker or in some other form.</li></ul><div id="36bcfe53-41bd-4567-8b42-fdeb886b4e75" class="column-list"><div id="98993790-3ee5-4439-b44c-3e98b34eaf07" style="width:56.25%" class="column"><pre id="233f2939-0f5a-4e73-a685-224d43a3afac" class="code"><code>Widget _searchBox() {
    return Padding(
      padding: EdgeInsets.all(global.device_size.height * 0.01),
      child: Card(
        child: ListTile(
          leading: Icon(Icons.search),
          title: TextField(
            controller: controller,
            decoration: const InputDecoration(
                hintText: &#x27;Search addresses&#x27;, border: InputBorder.none),
            onChanged: onSearchTextChanged,
          ),
          trailing: IconButton(
            icon: Icon(Icons.cancel),
            onPressed: () {
              controller.clear();
              onSearchTextChanged(&#x27;&#x27;);
            },
          ),
        ),
      ),
    );
  }</code></pre><pre id="9fe12179-3a01-4ad1-a727-1e44d4176bc6" class="code"><code>onSearchTextChanged(String text) async {
    _searchResults.clear();
    if (text.isEmpty) {
      setState(() {});
      return;
    }

    allDevices.forEach((device) {
      if (device.device.address.contains(text)) {
        _searchResults.add(device);
      }
    });

    setState(() {});
  }</code></pre><pre id="762700ea-adef-4180-a3ef-320095cb1b4d" class="code"><code>Widget _buildSearchItem(BuildContext context, int index) {
    late _DeviceWithAvailability result;

    result = _searchResults[index];
    final device = result.device;
    final address = device.address;
    late bool availability;
    switch (result.availability) {
      case _DeviceAvailability.no:
        availability = false;
        break;
      case _DeviceAvailability.yes:
        availability = true;
        break;
      case _DeviceAvailability.maybe:
        availability = false;
        break;
    }
    return Container(
        width: _cardSize * 1.1,
        height: _cardSize,
        child: Container(
            padding: const EdgeInsets.all(15),
            margin: const EdgeInsets.fromLTRB(0, 0, 0, 30),
            child: BluetoothCard(
              device: device,
              enabled: availability,
              type: result.type,
              rssi: result.rssi,
              onTap: () async {
                bool bonded = false;
                try {
                  if (device.isBonded) {
                    global.activeConnection = await BluetoothConnection
                            .toAddress(address)
                        .whenComplete(() =&gt; setState(() {
                              allDevices[allDevices.indexOf(result)] =
                                  _DeviceWithAvailability(
                                      BluetoothDevice(
                                        name: device.name ?? &#x27;&#x27;,
                                        address: address,
                                        type: device.type,
                                        isConnected: true,
                                        bondState: bonded
                                            ? BluetoothBondState.bonded
                                            : BluetoothBondState.none,
                                      ),
                                      result.availability,
                                      result.type,
                                      result.rssi);
                              _searchResults[_searchResults.indexOf(result)] =
                                  _DeviceWithAvailability(
                                      BluetoothDevice(
                                        name: device.name ?? &#x27;&#x27;,
                                        address: address,
                                        type: device.type,
                                        isConnected: true,
                                        bondState: bonded
                                            ? BluetoothBondState.bonded
                                            : BluetoothBondState.none,
                                      ),
                                      result.availability,
                                      result.type,
                                      result.rssi);

                              print(bonded
                                  ? BluetoothBondState.bonded
                                  : BluetoothBondState.none);
                            }));
                  } else {
                    bonded = (await FlutterBluetoothSerial.instance
                        .bondDeviceAtAddress(address))!;
                    global.activeConnection = await BluetoothConnection
                            .toAddress(address)
                        .whenComplete(() =&gt; setState(() {
                              allDevices[allDevices.indexOf(result)] =
                                  _DeviceWithAvailability(
                                      BluetoothDevice(
                                        name: device.name ?? &#x27;&#x27;,
                                        address: address,
                                        type: device.type,
                                        bondState: BluetoothBondState.bonded,
                                      ),
                                      result.availability,
                                      result.type,
                                      result.rssi);
                              _searchResults[_searchResults.indexOf(result)] =
                                  _DeviceWithAvailability(
                                      BluetoothDevice(
                                        name: device.name ?? &#x27;&#x27;,
                                        address: address,
                                        type: device.type,
                                        isConnected: true,
                                        bondState: bonded
                                            ? BluetoothBondState.bonded
                                            : BluetoothBondState.none,
                                      ),
                                      result.availability,
                                      result.type,
                                      result.rssi);

                              print(bonded
                                  ? BluetoothBondState.bonded
                                  : BluetoothBondState.none);
                            }));
                  }
                  setState(() {
                    allDevices[allDevices.indexOf(result)] =
                        _DeviceWithAvailability(
                            BluetoothDevice(
                              name: device.name ?? &#x27;&#x27;,
                              address: address,
                              type: device.type,
                              bondState: bonded
                                  ? BluetoothBondState.bonded
                                  : BluetoothBondState.none,
                            ),
                            result.availability,
                            result.type,
                            result.rssi);
                    _searchResults[_searchResults.indexOf(result)] =
                        _DeviceWithAvailability(
                            BluetoothDevice(
                              name: device.name ?? &#x27;&#x27;,
                              address: address,
                              type: device.type,
                              isConnected: true,
                              bondState: bonded
                                  ? BluetoothBondState.bonded
                                  : BluetoothBondState.none,
                            ),
                            result.availability,
                            result.type,
                            result.rssi);

                    print(bonded
                        ? BluetoothBondState.bonded
                        : BluetoothBondState.none);
                  });
                } catch (ex) {
                  print(ex);
                }
              },
              onLongPress: () async {
                try {
                  bool bonded = false;
                  if (device.isBonded) {
                    print(&#x27;Unbonding from ${device.address}...&#x27;);
                    await FlutterBluetoothSerial.instance
                        .removeDeviceBondWithAddress(address);
                    print(&#x27;Unbonding from ${device.address} has succed&#x27;);
                  } else {
                    print(&#x27;Bonding with ${device.address}...&#x27;);
                    bonded = (await FlutterBluetoothSerial.instance
                        .bondDeviceAtAddress(address))!;
                    print(
                        &#x27;Bonding with ${device.address} has ${bonded ? &#x27;succed&#x27; : &#x27;failed&#x27;}.&#x27;);
                  }
                  setState(() {
                    allDevices[allDevices.indexOf(result)] =
                        _DeviceWithAvailability(
                            BluetoothDevice(
                              name: device.name ?? &#x27;&#x27;,
                              address: address,
                              type: device.type,
                              bondState: bonded
                                  ? BluetoothBondState.bonded
                                  : BluetoothBondState.none,
                            ),
                            result.availability,
                            result.type,
                            result.rssi);
                    _searchResults[_searchResults.indexOf(result)] =
                        _DeviceWithAvailability(
                            BluetoothDevice(
                              name: device.name ?? &#x27;&#x27;,
                              address: address,
                              type: device.type,
                              isConnected: true,
                              bondState: bonded
                                  ? BluetoothBondState.bonded
                                  : BluetoothBondState.none,
                            ),
                            result.availability,
                            result.type,
                            result.rssi);
                  });
                } catch (ex) {
                  showDialog(
                    context: context,
                    builder: (BuildContext context) {
                      return AlertDialog(
                        title: const Text(&#x27;Error occured while bonding&#x27;),
                        content: Text(&quot;${ex.toString()}&quot;),
                        actions: &lt;Widget&gt;[
                          TextButton(
                            child: Text(&quot;Close&quot;),
                            onPressed: () {
                              Navigator.of(context).pop();
                            },
                          ),
                        ],
                      );
                    },
                  );
                }
              },
            )));
  }</code></pre></div><div id="1c2720ef-fd90-4168-847b-5780e3845c75" style="width:43.75000000000001%" class="column"><ul id="978cd85e-6f8b-4014-a971-20af6f62d213" class="bulleted-list"><li style="list-style-type:disc">A Search Box widget is used to filter out the devices and add them to the <code>searchResults</code>.</li></ul><ul id="ecc2e2ed-0808-4ef5-8ce5-35fc2a5b1c72" class="bulleted-list"><li style="list-style-type:disc">The widget is placed in the <code>AppBar</code>, with the <code>IconButton</code> to rescan for new devices.</li></ul><ul id="989a3d82-c74e-4fb7-aa51-fee395d2678f" class="bulleted-list"><li style="list-style-type:disc">If <code>searchResults</code> is not empty, the page shows the Widget Builder for the <code>searchResults</code> only.</li></ul><ul id="ccb9c5d4-c5aa-4259-95a5-a52d8f09b9ef" class="bulleted-list"><li style="list-style-type:disc">This widget builder is essentially identical to the widget builder for <code>allDevices</code>.</li></ul></div></div><p id="1f852779-73ab-41c5-9ffd-dcf32d4b6f35" class="">
</p><h3 id="aa95034d-83c3-4842-8572-f0a713bd095e" class="">Restarting the Device Scanning</h3><ul id="cc6f7a8e-16af-4be8-ba2a-28ef34a61349" class="bulleted-list"><li style="list-style-type:disc">This is done with a widget in the <code>AppBar</code>. It essentially empties <code>allDevices</code> and reruns the functions to retrieve new devices.</li></ul><p id="6bdc3377-ea32-4304-a0a4-ab4c55e9619e" class="">
</p><h1 id="d3a0a0d9-cb86-4c92-823a-b4c0d0a295b5" class="">What is Left?</h1><ul id="afa30903-36d8-45f9-88ea-060346c28a43" class="bulleted-list"><li style="list-style-type:disc">On tap, the <code>ConnectionInProgress</code> page should appear and close when the device is successfully paired.</li></ul><p id="b61fd21b-24f7-4154-9edf-986bde87d1a8" class="">
</p></div></article></body></html>